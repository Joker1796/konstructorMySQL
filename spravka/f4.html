<!DOCTYPE html>

<html>

	<head>
		<meta charset="UTF-8">
		<title>Конструктор запросов</title>
		<link rel="stylesheet" href="../style.css">
		<script src="../jquery-3.2.1.min.js"></script>
		<script src="../script.js"></script>
	</head>
	
<body>

<!--================= ШАПКА ===================-->
	<header>
		<div class="hed">
			<div class="men1"><a href="../index.html"><img class="logo" src="logo.png"></a>	</div>
			<div class="men"><a href="../index.html">Что это?</a></div>
			<div class="men"><a href="../kostruct.html">Занятия</a></div>
			<div class="men"><a href="../faq.html">Справочник</a></div>
			
		</div>
	</header>
	
<!--================= КОНТЕНТ ===================-->
<a href="#top"><img class="strelka" src="../up.png"></a>

<div class="hr_zagolovok">Создание таблицы в базе данных MySQL (CREATE TABLE)</div>
	<div class="content">
Создание таблицы в базе данных производится командой <b>CREATE TABLE</b>.

			<h2>Синтаксис:</h2>
			<hr>
			<div class="vid_zap">
				CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name [(create_definition,...)]
				<br>
				[table_options] [select_statement]
			</div>
		<p>
			<b>tbl_name</b>
			- Задает имя таблицы, которая будет создана в текущей базе данных. Если никакая база данных на 
			момен вызова команды <b>CREATE TABLE</b> не была принята текущей, то возникнет ошибка выполнения команды. 
			Начиная с MySQL 3.22 введена возможность явно указать базу данных, в которой будет создана новая 
			таблица, при помощи синтаксиса db_name.tbl_name.
		</p>
		<p>
			<b>TEMPORARY</b>
			- Этот параметр используется для создания временной таблицы с именем tbl_name в течении только 
			текущего сценария. По окончанию выполнения сценария созданная таблица удаляется. Данная возможность 
			появилась в MySQL 3.23 В MySQL 4.0.2 для создания временных таблиц требуются привелегии <b>CREATE 
			TEMPORARY TABLES.</b>
		</p>
		<p>
			<b>IF NOT EXISTS</b>
			- Если указан этот параметр и производится попытка создать таблицу с дублирующим именем (т.е. 
			таблица с таким именем в текущей БД уже есть), то таблица создана не будет и сообщение об ошибке 
			не появиться. В противном случае таблица также создана не будет, но команда вызовет ошибку. 
			Следует отметить, что при создании сравниваются только имена таблиц. Внутренние структуры не 
			сравниваются.
		</p>
		<p>
			<b>create_definition</b>
			- Определяет внутреннюю структуру создаваемой таблицы (названия и типы полей, ключи, индексы и т.д.)
		</p>
			Возможные синтаксисы create_definition:
			<div class="vid_zap">col_name type [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT] [PRIMARY KEY] 
			[reference_definition]</div>
			или
			<div class="vid_zap">PRIMARY KEY (index_col_name,...)</div>
			или
			<div class="vid_zap">KEY [index_name] (index_col_name,...)</div>
			или
			<div class="vid_zap">INDEX [index_name] (index_col_name,...)</div>
			или
			<div class="vid_zap">UNIQUE [INDEX] [index_name] (index_col_name,...)</div>
			или
			<div class="vid_zap">FULLTEXT [INDEX] [index_name] (index_col_name,...)</div>
			или
			<div class="vid_zap">[CONSTRAINT symbol] FOREIGN KEY [index_name] (index_col_name,...) [reference_definition]</div>
			или
			<div class="vid_zap">CHECK (expr)</div>
		<p>
			<b>col_name</b>
			- Задает имя столбца в создаваемой таблице.
		</p>
		<p>
			<b>type</b>
			- Задает тип данных для столбца col_name.
		</p>
			Возможные значения параметра type:
<pre>
	TINYINT[(length)] [UNSIGNED] [ZEROFILL]
	SMALLINT[(length)] [UNSIGNED] [ZEROFILL]
	MEDIUMINT[(length)] [UNSIGNED] [ZEROFILL]
	INT[(length)] [UNSIGNED] [ZEROFILL]
	INTEGER[(length)] [UNSIGNED] [ZEROFILL]
	BIGINT[(length)] [UNSIGNED] [ZEROFILL]
	REAL[(length,decimals)] [UNSIGNED] [ZEROFILL]
	DOUBLE[(length,decimals)] [UNSIGNED] [ZEROFILL]
	FLOAT[(length,decimals)] [UNSIGNED] [ZEROFILL]
	DECIMAL(length,decimals) [UNSIGNED] [ZEROFILL]
	NUMERIC(length,decimals) [UNSIGNED] [ZEROFILL]
	CHAR(length) [BINARY]
	VARCHAR(length) [BINARY]
	DATE
	TIME
	TIMESTAMP
	DATETIME
	TINYBLOB
	BLOB
	MEDIUMBLOB
	LONGBLOB
	TINYTEXT
	TEXT
	MEDIUMTEXT
	LONGTEXT
	ENUM(value1,value2,value3,...)
	SET(value1,value2,value3,...)
</pre>
		<p>
			Подробнее о допустимых типах столбцов и их синтаксисе смотрите 
			<a href="../spravka/f1.html">Типы данных, используемые в базе данных MySQL</a>
		</p>
		<p>
			<b>[NOT NULL | NULL]</b>
			- Указывавет, может ли данных столбец содержать значение NULL или нет. Если не указано, то 
			по умолчанию принимается NULL (т.е. может содержать NULL).
		</p>
		<p>
			<b>[DEFAULT default_value]</b>
			- Задает значение по умолчанию для данного столбца. При вставке новой записи в таблицу командой 
			<b>INSERT</b> если значение для поля col_name явно указано не было, то устанавливается значение default_value.
		</p>
		<p>
			<b>[AUTO_INCREMENT]</b>
			- При вставке новой записи в таблицу поле с этим атрибутом автоматически получит числовое 
			значение, на 1 больше самого большого значения для этого поля в текущий момент времени. 
			Данная возможность обычно используется для генерирования уникальных идентификаторов строк. 
			Столбец, для которого применяется атрибут AUTO_INCREMENT, должен иметь целочисленный тип. 
			В таблице может быть только один столбец с атрибутом AUTO_INCREMENT. Так же этот столбец должен 
			быть проиндексирован. Отсчет последовательности чисел для AUTO_INCREMENT начинается с 1. Это 
			могут быть только положительные числа.
		</p>
		<p>
			Следующий пример создает таблицу users с 3 полями, где первое поле - уникальный идентификатор 
			записи, второе поле - имя пользователя, а третье поле - его возраст:
		</p>
<div class="vid_zap">
<pre>
CREATE TABLE
	`users` (
		`id` INT(11) NOT NULL AUTO_INCREMENT,
		`name` CHAR(30) NOT NULL,
		`age` SMALLINT(6) NOT NULL,
		PRIMARY KEY(`id`)
	)
</pre>
</div>
			Вставляем четыре новые записи:
<div class="vid_zap">
<pre>
INSERT INTO
	`users` (`name`, `age`)
VALUES
	('Катя', 12),
	('Лена', 18),
	('Миша', 16),
	('Саша', 20)
</pre>
</div>
			Выводим все записи таблицы users:
<div class="vid_zap">
<pre>
SELECT
	*
FROM
	`users`
</pre>
</div>
			Полученный результат:
<div class="vid_zap">
<pre>
+----+------+-----+
| id | name | age |
+----+------+-----+
|  1 | Катя |  12 |
|  2 | Лена |  18 |
|  3 | Миша |  16 |
|  4 | Саша |  20 |
+----+------+-----+
4 rows in set (0.00 sec)
</pre>
</div>
		<p>
			В таблицах MyISAM и BDB существует возможность задавать параметр AUTO_INCREMENT для вторичного 
			столбца составного ключа.<br>
			В этом случае ключем записи (его уникальным значением) будет являться значение сразу двух полей. 
			При этом первое поле является своеобразным префиксом, а второе уже как раз уникальным числовым 
			значением для этого префикса.<br>
			Эту особенность удобно использовать, если необходимо добавлять новые данные по группам.
		</p>
		<p>
			Покажем эту особенность на следующем примере:<br>
			Допустим, нам необходимо записывать свои контакты в таблицу. Создаем таблицу users с четырьмя 
			полями для записи.<br>
			Первое поле содержит тип контакта (дом, работа, учеба);<br>
			второе поле - уникальный идентификатор записи;<br>
			третье поле - имя человека;<br>
			четвертое поле - его возраст.
		</p>
<div class="vid_zap">
<pre>
CREATE TABLE
	`users` (
		`category` ENUM('дом', 'работа', 'учеба') NOT NULL,
		`id` MEDIUMINT NOT NULL AUTO_INCREMENT,
		`name` CHAR(30) NOT NULL,
		`age` SMALLINT(6) NOT NULL,
		PRIMARY KEY(`id`, `category`)
	)
</pre>
</div>
			Вставляем в созданную таблицу новые записи:
<div class="vid_zap">
<pre>
INSERT INTO
	`users` (`category`, `name`, `age`)
VALUES
	('дом', 'Оля', 26),
	('дом', 'Настя', 20),
	('работа', 'Артем', 26),
	('учеба', 'Дима', 25),
	('работа', 'Саша', 27),
	('учеба', 'Миша', 25),
	('работа', 'Лена', 35)
</pre>
</div>
			Теперь просмотрим все записи в таблице users, упорядочив их по полю category и id:
<div class="vid_zap">
<pre>
SELECT
	*
FROM
	`users`
GROUP BY
	`category`, `id`
</pre>
</div>
			Вот что получится в результате:
<div class="vid_zap">
<pre>
+----------+----+-------+-----+
| category | id | name  | age |
+----------+----+-------+-----+
| дом      |  1 | Оля   |  26 |
| дом      |  2 | Настя |  20 |
| работа   |  3 | Артем |  26 |
| работа   |  5 | Саша  |  27 |
| работа   |  7 | Лена  |  35 |
| учеба    |  4 | Дима  |  25 |
| учеба    |  6 | Миша  |  25 |
+----------+----+-------+-----+
7 rows in set (0.00 sec)
</pre>
</div>
			Чтобы получить значение ID последней вставленной записи, можно воспользоваться командой MySQL
<div class="vid_zap">
<pre>
SELECT
	LAST_INSERT_ID()
</pre>
</div>
		<p>
			Либо функцией API mysql_insert_id().
		</p>
		<p>
			<b>[PRIMARY KEY]</b>
			- Задает первичный ключ таблицы.
		</p>
		<p>
			В таблице может быть задан только одни первичный ключ. Все значения столбца, помеченного как 
			перичный ключ, не должны содержать значения NULL. Если при создании таблицы первичный ключ явно 
			указан не был, а приложение его запрашивает, то БД MySQL автоматически устанавливает первый 
			столбец с параметром UNIQUE, если во всех значениях этого столбца нигде не встречается значение NULL.
		</p>
		<p>
			В качестве первичного ключа можно задать как один, так и несколько столбцов:
		</p>
		<div class="vid_zap">
			PRIMARY KEY(col_1, col_2, ...)
		</div>
		<p>
			Только в этом случае ни один другой столбец не может быть первичным, т.е. не может быть описан:
		</p>
		<div class="vid_zap">
			PRIMARY KEY(col_1), PRIMARY KEY(col_1, col_2)
		</div>
		<p>
			Поля PRIMARY KEY являются проиндексированными полями (более подробную информацию по индексам 
			читайте далее в INDEX).
		</p>
		<p>
			<b>KEY</b>
			- Является синонимом к INDEX
		</p>
		<p>
			<b>INDEX</b>
			- Задает поля, которые будут проиндексированы.
		</p>
		<p>
			Индексация полей полезна для ускорения работы команды <b>SELECT</b> (причем ускорение порой бывает очень 
			даже хорошее).
		</p>
		<p>
			В качестве наглядного примера пользы от использования индексов можно взять книгу. В ней индексами 
			будет являться оглавление. Если нам в книге надо найти определенный раздел и нет оглавления, то 
			придется всю книгу перелистывать страница за страницей, пока нужный раздел не будет найден. А с 
			оглавлением мы быстро можем найти любое место в книге за считанные секунды. Тоже самое и с таблицей. 
			Если у таблицы нет индексов, то при поиске определенного значения MySQL "проходится" по всем 
			записям таблицы и пытается найти необходимое значение. Если задать поля, которые должны быть 
			проиндексированы, то MySQL создает специальное хранилище, в котором содержатся все значения 
			проиндесированных полей таблицы и точное местоуказание, где это значение находится. Т.е. поиск 
			значения происходит практически мгновенно, что несомненно сказывается на скорости выполнения скрипта.
		</p>
		<p>
			Но за удобство и скорость работы приходится платить. В случае с индексами оплатой является 
			увеличение базы данных примерно в два раза.
		</p>
		<p>
			В MySQL проиндексированы могут быть поля любого типа. Для ускорения работы в полях типа CHAR и 
			VARCHAR можно индексировать только несколько первых символов.
		</p>
		<p>
			При задании индексов необходимо учитывать, что только у таблиц типа MyISAM, InnoDB и BDB 
			индексируемое поле может иметь значения NULL. Чтобы небыло ошибок советуют полям, которые будут 
			проиндексированы, всегда назначать NOT NULL.
		</p>
		<p>
			Если параметр index_name, который задает имя индекса, не указан, то индесу присвоится имя первого 
			индексируемого столбца.
		</p>
		<p>
			В следующем примере создадим таблицу users с полями name и age и проиндексируем таблицу по полю 
			name по первым 12 буквам:
		</p>
		<p>
<div class="vid_zap">
<pre>
CREATE TABLE
	`users` (
		`name` CHAR(200) NOT NULL,
		`age` SMALLINT(3),
		INDEX (`name`(12))
	)
</pre>
</div>
		<p>
			Если для столбцов CHAR и VARCHAR было желательным индексирование только части столбца, то для 
			полей типа TEXT и BLOB это является обязательным. При этом поля с типом TEXT или BLOB могут быть 
			проиндексированы только в таблице типа MyISAM.
		</p>
		<p>
			Получить сведения о индексах таблицы tbl_name можно выполнив следующий SQL-запрос:
		</p>
<div class="vid_zap">
<pre>
SHOW INDEX FROM
	`tbl_name`
</pre>
</div>	
		<p>
			<b>UNIQUE</b>
			- Этот ключ указывает на то, что данный столбец может иметь только уникальные значения. При 
			попытке добавления повторяющегося значения в таблицу в поле с ключом UNIQUE, эта операция 
			завершится ошибкой.
		</p>
		<p>
			Уникальными можно задать как один, так и несколько столбцов:
		</p>
<div class="vid_zap">
<pre>
CREATE TABLE
	`users` (
		`name` VARCHAR(200) NOT NULL,
		`address` VARCHAR(255) NOT NULL,
		UNIQUE(`name`, `address`)
	)
</pre>
</div>
		<p>
			<b>FULLTEXT</b>
			- Задает поля, к которым в последствии может быть применен полнотекстный поиск.
		</p>
		<p>
			Полнотекстный поиск является средством MySQL, направленным на поиск нужной информации в базе 
			данных и выводе результатов в соответствии с релевантностью найденных строк относительно 
			поискового запроса.
		</p>
		<p>
			Полнотестный поиск введен в MySQL начиная с версии 3.23.23 для таблиц типа MyISAM и только 
			для полей типа VARCHAR и TEXT.
		</p>
		<p>
			При индексировании полей с ключом FULLTEXT происходит индексация всего значения, а не его части 
			(т.е. задать для индексации первые n-символов НЕЛЬЗЯ).
		</p>
		<p>
			<b>FOREIGN KEY</b> и <b>CHECK</b>
			- Введены для совместимости при переносе кода с других SQL-баз данных при запуске приложений, 
			создающих таблицы со ссылками.<br>
			Фактически ничего не делают.
		</p>
		<p>
			<b>table_options</b>
			- Задает дополнительные параметры создаваемой таблицы.
		</p>
		<p>
			Данная возможность появилась в MySQL начиная с версии 3.23.
			Возможные дополнительные параметры:
		</p>
<div class="vid_zap">
<pre>
	TYPE = {BDB | HEAP | ISAM | InnoDB | MERGE | MRG_MYISAM | MYISAM }
	AUTO_INCREMENT = #
	AVG_ROW_LENGTH = #
	CHECKSUM = {0 | 1}
	COMMENT = "string"
	MAX_ROWS = #
	MIN_ROWS = #
	PACK_KEYS = {0 | 1 | DEFAULT}
	PASSWORD = "string"
	DELAY_KEY_WRITE = {0 | 1}
	ROW_FORMAT= { default | dynamic | fixed | compressed }
	RAID_TYPE= {1 | STRIPED | RAID0 } RAID_CHUNKS=# RAID_CHUNKSIZE=#
	UNION = (table_name,[table_name...])
	INSERT_METHOD= {NO | FIRST | LAST }
	DATA DIRECTORY="абсолютный путь к каталогу"
	INDEX DIRECTORY="абсолютный путь к каталогу"
</pre>
</div>
		<p>
			<b>TYPE</b>
			- Задает тип создаваемой таблицы.<br>
			Возможные типы таблиц в MySQL:
		</p>
<div class="vid_zap">
<pre>
	BDB - Таблицы с поддержкой транзакций и блокировкой страниц.
	HEAP - Данные этой таблицы храняться только в памяти.
	ISAM - Оригинальный обработчик таблиц.
	InnoDB - Таблицы с поддержкой транзакций и блокировкой строк.
	MERGE - Набор таблиц MyISAM, используемый как одна таблица.
	MRG_MYISAM - Псевдоним для MERGE.
	MyISAM - Новый обработчик, обеспечивающий переносимость 
	таблиц в бинарном виде, который заменяет ISAM.
</pre>
</div>
		<p>
			<b>AUTO_INCREMENT</b>
			- Устанавливает для данной таблицы следующее значение AUTO_INCREMENT.
		</p>
		<p>
			<b>AVG_ROW_LENGTH</b>
			- Приближенное значение средней длины строки для данной таблицы. Имеет смысл устанавливать 
			только для обширных таблиц с записями переменной длины.
		</p>
		<p>
			<b>CHECKSUM</b>
			- Следует установить в 1, чтобы в MySQL поддерживалась проверка контрольной суммы для всех 
			строк (это делает таблицы немного более медленными при обновлении, но позволяет легче находить 
			поврежденные таблицы) (MyISAM).
		</p>
		<p>
			<b>COMMENT</b>
			- Комментарий для данной таблицы длиной 60 символов.
		</p>
		<p>
			<b>MAX_ROWS</b>
			- Максимальное число строк, которые планируется хранить в данной таблице.
		</p>
		<p>
			<b>MIN_ROWS</b>
			- Минимальное число строк, которые планируется хранить в данной таблице.
		</p>
		<p>
			<b>PACK_KEYS</b>
			- Следует установить в 1 для получения меньшего индекса. Обычно это замедляет обновление и 
			ускоряет чтение (MyISAM, ISAM). Установка в 0 отключит уплотнение ключей. При установке в 
			DEFAULT (MySQL 4.0) обработчик таблиц будет уплотнять только длинные столбцы CHAR/VARCHAR.
		</p>
		<p>
			<b>PASSWORD</b>
			- Шифрует файл `.frm' с помощью пароля. Эта опция не функционирует в стандартной версии MySQL.
		</p>
		<p>
			<b>DELAY_KEY_WRITE</b>
			- Установка в 1 задерживает операции обновления таблицы ключей, пока не закроется указанная 
			таблица (MyISAM).
		</p>
		<p>
			<b>ROW_FORMAT</b>
			- Определяет, каким образом должны храниться строки. В настоящее время эта опция работает 
			только с таблицами MyISAM, которые поддерживают форматы строк DYNAMIC и FIXED.
		</p>
		<p>
			<b>RAID_TYPE</b>
			- Воспользовавшись опцией RAID_TYPE, можно разбить файл данных MyISAM на участки с тем, чтобы 
			преодолеть 2Гб/4Гб лимит файловой системы под управлением ОС, не поддерживающих большие файлы. 
			Разбиение не касается файла индексов. Следует учесть, что для файловых систем, которые 
			поддерживают большие файлы, эта опция не рекомендуется! Для получения более высокой скорости 
			ввода-вывода можно разместить RAID-директории на различных физических дисках. RAID_TYPE будет
			 работать под любой операционной системой, если конфигурация MySQL выполнена с параметром 
			 --with-raid. В настоящее время для опции RAID_TYPE возможен только параметр STRIPED (1 и RAID0 
			 являются псевдонимами для него). Если указывается RAID_TYPE=STRIPED для таблицы MyISAM, то MyISAM 
			 создаст поддиректории RAID_CHUNKS с именами `00', `01', `02' в директории базы данных. В каждой 
			 из этих директорий MyISAM создаст файл `table_name.MYD'. При записи данных в файл данных 
			 обработчик RAID установит соответствие первых RAID_CHUNKSIZE*1024 байтов первому упомянутому 
			 файлу, следующих RAID_CHUNKSIZE*1024 байтов - следующему файлу и так далее.
		</p>
		<p>
			<b>UNION</b>
			- Опция UNION применяется, если необходимо использовать совокупность идентичных таблиц как 
			одну таблицу. Она работает только с таблицами MERGE. На данный момент для таблиц, сопоставляемых 
			с таблицей MERGE, необходимо иметь привилегии SELECT, UPDATE и DELETE. Все сопоставляемые таблицы 
			должны принадлежать той же базе данных, что и таблица MERGE.
		</p>
		<p>
			<b>INSERT_METHOD</b>
			- Для внесения данных в таблицу MERGE необходимо указать с помощью INSERT_METHOD, в какую таблицу 
			данная строка должна быть внесена. Эта опция была введена в MySQL 4.0.0.
		</p>
		<p>
			<b>DATA DIRECTORY</b> и <b>INDEX DIRECTORY</b>
			- Используя опции DATA DIRECTORY="каталог" или INDEX DIRECTORY="каталог", можно указать, где 
			обработчик таблицы должен помещать свои табличные и индексные файлы. Следует учитывать, что 
			указываемый параметр directory должен представлять собой полный путь к требуемому каталогу 
			(а не относительный путь). Данные опции работают только для таблиц MyISAM в версии MySQL 4.0, 
			если при этом не используется опция --skip-symlink.
		</p>
		<p>
			<b>select_statement</b>
			- Добавляет к создаваемой таблице поля и значения, полученные в результате работы команды SELECT.
			Приведем наглядный пример.
		</p>
		<p>
			Допустим, у нас есть таблица с именами городов:
		</p>
<div class="vid_zap">
<pre>
CREATE TABLE
	`city`(
		`name` CHAR(200) NOT NULL
	)
</pre>
</div>
<div class="vid_zap">
<pre>
INSERT INTO
	`city`
VALUES
	('Москва'),
	('Рязань'),
	('Луховицы'),
	('Коломна')
</pre>
</div>
			<p>и мы хотим создать таблицу с именами пользователей и названием городов где они живут:</p>
<div class="vid_zap">
<pre>
CREATE TABLE
	`users`(
		`id` INT(11) NOT NULL AUTO_INCREMENT,
		`name` CHAR(200) NOT NULL,
		PRIMARY KEY(`id`)
	)
SELECT
	*
FROM
	`city`
</pre>
</div>
		<p>
			Теперь таблица user имеет стобцы и содержит значения:
		</p>
		<p>
			Приведенный пример никакой смысловой нагрузки не несет, т.к. поле name не получило никаких 
			значений. Здесь просто показан принцып присоединения слева новых столбцов при помощи конструкции <b>SELECT</b>.
		</p>
		<p>
			Еще пример:
		</p>
<div class="vid_zap">
<pre>
CREATE TABLE
	`city_new`
SELECT
	`id`,
	`city_name` AS `name`
FROM
	`users`
</pre>
</div>
<div class="vid_zap">
<pre>				
SELECT
	*
FROM
	`city_new`
</pre>
</div>
<div class="vid_zap">
<pre>				
+----+----------+
| id | name     |
+----+----------+
|  1 | Москва   |
|  2 | Рязань   |
|  3 | Луховицы |
|  4 | Коломна  |
+----+----------+
4 rows in set (0.00 sec)
</pre>
</div>
	<hr>
		<div class="next">
			<button class="button"><a href="f3.html">< Предыдующая статья</a></button>
			<button class="button"><a href="f5.html">Следующая статья ></a></button>
		</div>
	</div>
	
<!--================= ПОДВАЛ ===================-->
	<footer>
		<div class="foot">
			ГПОУ ЯО Ростовский педагогический колледж  2017-2019 <sup>©</sup>
		</div>	
	</footer>
	
</body>
</html>
<!---->